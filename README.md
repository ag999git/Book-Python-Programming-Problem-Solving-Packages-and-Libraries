## Introduction
This repository contains various types of files which will help you in your Python course if you are following the book **Python Programming: Problem Solving, Packages and Libraries** 
The book has 20 chapters in the print/ Kindle format and another 5 chapters which can be downloaded from the McGraw Hill web site.

The repository has the following folders:-

 1. Online-chapters-21-25
 2. book-chapters-html
 3. PPT-notes-as-pdf

The first folder contains the last 5 chapters of my book in pdf format. You can download these chapters. The chapters are complete in all respects.

The other 2 folders (at serial number 2 and 3) contain help guides for each of the 20 chapters in the book in html, pptx (converted to pdf) format. However the formats may not render accurately on GitHub. So you need to either download or clone the repository to your local machine and then view them with appropriate viewer application. For example you may download the pptx files in pdf and then view them with a pdf viewer. Similarly you can view the html files in your favourite web browser.
The book is available in print/ kindle [here](https://www.amazon.in/Books-Gupta-Biswas/s?rh=n%3A976389031%2Cp_27%3AGupta+Biswas "Link to Book on Amazon")

Given below are the topics contained in the book
### Table of Contents
**Chapter 1 Python Basics—I**  
1.1 Introduction  
1.2 Basic Concepts  
1.2.1 History and Introduction 
1.2.2 A Very Brief Note on Versions Python 2.x and 3.x 2  
1.2.3 Features   
1.2.4 Compiler versus Interpreter 
1.2.5 Open Source versus Propriety (Also free vs. paid)   
1.2.6 Portable   
1.3 Basic Concepts  
1.3.1 Dynamic Typing or Dynamic Binding   
1.3.2 Automatic Memory Management  
1.3.3 Command Line versus Script Mode  
1.3.4 IPython, Anaconda and Conda   
1.3.5 Jupyter Notebook   
1.3.6 Relation of Anaconda to Spyder IDE and Jupyter Notebook   
1.3.7 Difference between Jupyter Notebook and Spyder   
1.3.8 Using Python Interactive Mode as a Calculator   
1.4 Basic Concepts   
1.4.1 Using Simple Print Statement in Python 2.x (which is print() function in 3.x)   
1.4.2 Executing Python from a “file” i.e. a “script” Rather than Command Line 
1.4.3 Single Line Comments and Multi-line Comments   
1.5 Some Aspects of Python Statements and Indentation  
1.5.1 Explicit Line Continuation 
1.5.2 Implicit Multiline Statement 
1.5.3 Multiple Statements in Single Line Using Semicolons   
1.5.4 Python Indentation  
1.6 Python Keywords, Identifiers and Variables  
1.6.1 Python Keywords and Identifiers  
1.6.2 Variables, Literals, References and Built-in Types  
1.6.3 Variable   
1.6.4 Assignment  
1.6.5 Reference in Python 
1.6.6 Shared Reference 
1.6.7 Variable vs. Identifier  

**Chapter 2 Python Basics—II**  
2.1 Introduction  
2.2 Data Types in Python   
2.2.1 Numbers (Integers, Floating Points, Complex and Bool)   
2.2.2 Complex (Complex Numbers)   
2.2.3 Bool   
2.2.4 Sequence and Other Containers (Non-sequenced Containers)   
2.2.5 None   
2.3 Mutable versus Immutable   
2.4 Type Casting (also called Type Conversion) in Python  
2.4.1 Explicit versus Implicit Type Casting   
2.4.2 Implicit Type Conversion in Boolean Context   
2.5 Input to a Python Program   
2.6 Modular Programming and Python Modules   
2.6.1 Accessing the Attributes and Methods of a Module   
2.6.2 Function Defined Inside Modules are Called Methods of the Module   
2.7 Strings (Basics)   
2.7.1 Using String Function len(str) on a “Literal String”   
2.7.2 Applying a Function and a Method to a Variable, which Refers to a  
String   
2.7.3 Python Strings are “immutable”   
2.7.4 A String as a Sequence of Character in the Memory   
2.7.5 The ‘+’ Operator Can Concatenate Two Strings  
2.7.6 The str(object) Function Converts Objects to Strings   
2.7.7 Single Quotes Within Double Quotes   
2.7.8 Indexing of Strings  
2.7.9 Slicing of Strings   
2.8 Binary Literals in Python   
2.9 The Zen of Python on Jupyter  
**Chapter 3 Operators in Python**  
3.1 Introduction  
3.2 Assignment (and reassignment)  
3.3 Overview of Operators  
3.3.1 Some Common Arithmetic Operators   
3.3.2 Order of Precedence of Operators   
3.3.3 Comparison   
3.3.4 Logical Operators   
3.3.5 Bitwise Operators 5 
3.3.6 Boolean Operators versus Bit-wise Operators   
3.3.7 Special Operators   
3.3.8 Identity Operator   
3.3.9 Membership Operator   
**Chapter 4 Functions—Part I**   
4.1 Introduction   
4.2 Need for Functions  
4.3 Basics of Functions   
4.3.1 Built-in Functions  
4.3.2 Functions in Modules   
4.3.3 Calling a Function (As Opposed to Defining or Writing a Function)   
4.3.4 Some Important Built-in Functions in Python   
4.3.5 Some Important Functions in Modules in Python   
4.4 Defining your own functions and function syntax   
4.4.1 Syntax for Writing/Defining Your Function   
4.3.7 Scope namespace and Lifetime of Variables   
**Chapter 5 Functions—Part II**   
5.1 Introduction 
5.2 Passing Variables in a Function Call  
5.3 Function Arguments  
5.3.1 Providing Default Arguments or Parameter Values 
5.3.2 Passing of Arguments by Position  
5.3.3 Keyword Arguments  
5.3.4 Using “Default-values” and “Keyword-arguments” Together   
5.3.5 Using Variable Number of Arguments in a Function Call by Using the Syntax  with `*`  in Function Definition  
5.3.6 Using `**` kwarg in Function Definition to Pass a Key Worded, Variable-length  of Arguments  
5.4 Additional Note on Modules in Python  
5.4.1 How Python Interpreter Searches for Modules  
5.4.2 Using if `__name__ == “__main__”:`  
5.5 Recursion 
5.5.1 Recursive Function to Find Factorial of a Number  
5.5.2 Recursive Function to Find a Number is Even or Not (not very efficient) 
5.5.3 Recursive Function to find ab   
5.5.4 Recursive Function to Generate Fibonacci Numbers 1 
5.5.5 Recursion versus Iteration (Advantage/Disadvantage of Recursion)  
5.5.6 Recursion Example: Tower of Hanoi  
5.5.7 Memoizing Example: Fibonacci Series 
5.6 Some Special Functions  
5.6.1 zip Function   
5.6.2 Using zip to unzip  
5.6.3 Lambda Functions  
5.6.4 map() Function   
5.6.5 filter() Function   
5.6.6 Generator Functions  

**Chapter 6 Flow Control**  
6.1 Introduction 
6.2 Using ‘if’  
6.2.1 If…elif…else statement  
6.2.2 if…else Statement (Without elif)  
6.2.3 Omitting the Else Clause (i.e., Using an ‘if’ Without an ‘else’)   
6.2.4 Nested if... else Statements 
6.2.5 How to Avoid nested if (Good Programming Technique) 
6.3 while Loop 
6.3.1 Basics of while Loop  
6.3.2 break, continue and pass statements 
6.3.3 while With else  
6.3.4 Python does not have “do- - until”   
6.3.5 pass Statement  
6.3.6 Infinite loop   
6.4 for Loop  
6.4.1 Basics of “for” loop   
6.4.2 Nested for loops   
6.4.3 When to Use ‘while’ and When to Use ‘for’ Loop   
6.5 range Function 
6.5.1 The Function range([start], stop[, step])  
6.5.2 Using range() Function in Loop 
6.5.3 Using “in” Operator versus Using range() Function in “for” Loop 
6.6 Common Errors in Flow Control 
6.7 Iterable 
 **Chapter 7 Strings**  
7.1 Introduction 
7.2 Creating, Initializing and Accessing Elements of a String 
7.2.1 Creating Strings   
7.2.2 String Indexing 
7.2.3 Special Character and Escape Sequence 
7.3 Traversing a String  
7.3.1 Traversing a String using ‘for’ Loop  
7.3.2 Traversing a String using while Loop 
7.3.3 Traversing a String using ‘for’ Loop with the range() Function   
7.4 String Operations   
7.4.1 The plus, that is, ‘ + ’ operator   
7.4.2 The multiplication operator `* `   
7.4.3 Operators`in` and `not in`   
7.4.4 String slicing   
7.4.5 String Extended Slicing  
7.4.6 Comparison of Strings using Relational Operators  
7.5 Difference between Functions, Methods and Attributes  
7.6 String Functions versus String Methods 
7.6.1 str.capitalize() where str is a String  
7.6.2 str.count(sub[, start[, stop]]) 
7.6.3 Checking for a Palindrome   
7.7 A Short Note on String Module   
**Chapter 8 Lists**   
8.1 Introduction   
8.2 Some Basic Concepts of Lists   
8.2.1 Concept of Containers(or collections), Sequence and Mapping  
8.2.2 Mutability 
8.2.3 Sequences in Python  
8.2.4 Some Common Operations on Sequences 
8.3 Creating, Traversing and Slicing Lists  
8.3.1 Creating list 
8.3.2 List Comprehension (Comprehension means construction)   
8.3.3 Traversing the list (ie iterating over items of a list)   
8.3.4 Ways of Adding to a List 
8.3.5 list slicing   
8.3.6 myList[start: end] or myList[m:n]  
8.3.7` myList[m:n:s]` or `mylist[start:end:step`]   
8.3.8 Index and Slice Assignment  
8.3.9 Difference between Assigning a List to Another List and Copying a List  
8.3.10 Concept of Aliasing  
8.4 List Functions and Methods   
8.4.1 len   
8.4.2 sort 
8.4.3 Searching, Adding, Removing, Reversing, and Others  
8.4.4 index() Method   
8.4.5 List method: pop 
8.4.6 List in Boolean Context 
8.5 Nested Lists and Using Them as Matrix   
8.5.1 Sample Script (To Initialize Items in a Matrix)   
8.5.2 Sample Script (Get Items in Diagonals of a Matrix)   
8.5.3 Sample Script (Add all Numbers which are even in a Matrix)   
8.5.4 Sample Script (Upper/Lower Triangle Matrix)  
**Chapter 9 Dictionaries**   
9.1 Introduction   
9.2 Basics of Dictionary—1   
9.2.1 Properties of a Dictionary  
9.2.2 Concept of Hashable   
9.2.3 Mutability of Dictionary   
9.2.4 Creating, Initializing, Accessing Elements   
9.3 Basic Concepts—2
9.3.1 Dictionary Comprehension   
9.3.2 Checking for Presence/Absence of a Key in a Dictionary  
9.3.3 Traversing a Dictionary 
9.3.4 Duplicate Keys are Not Allowed (But duplicate values are allowed)   
9.3.5 Keys Must be Immutable (Must be “Hashable” Objects)   
9.4 Dictionary Functions and Methods 
9.4.1 sorted(d) 
9.4.2 del d[key]  
9.4.3 len(d)
9.4.4 cmp(d1, d2) (Where d1 and d2 are two dictionaries being compared) 
9.5 Dictionary Methods 
9.5.1 d.clear() 
9.5.2 d.get(some_key [, default_value])  
9.5.3 d. has_key()  
9.5.4 d.keys() 
9.5.5 d.values() 
9.5.6 d.items() 
9.5.7 d1.update(d2) (where d1 and d2 are dictionaries) 
9.6 Dictionary View Objects 
**Chapter 10 Tuples**   
10.1 Introduction 
10.2 Some Basic Concepts Regarding Tuples 
10.2.1 Immutability Concept 
10.2.2 Creating, initializing and Accessing Elements 
10.2.3 Accessing Items in a Tuple and Creating New Tuples from Existing 
10.2.4 Short Note on Creating a Tuple Slice 
10.2.5 Creating a Tuple from User Input (Using + Operator) 
10.2.6 Immutability versus Reassignment 
10.2.7 Other Features of Tuples 
10.3 Some Additional Topics  
10.3.1 Operations  
10.3.2 Some Common Tuple Functions 
10.3.3 Swapping Tuples 
10.3.4 Unpacking Tuples 
**Chapter 11 Regular Expression**   
11.1 Introduction 
11.2 Basic Concepts of Regular Expressions  
11.2.1 Raw Strings in Python 
11.2.2 The Concept of RE 
11.3 Special Characters, Groups of Characters and Anchors   
11.3.1 Special Characters  
11.3.2 Matching Group of Characters 
11.3.3 Start of String and End of String Anchors  
11.4 Understanding Re Module 
11.5 The Match object and match(), search() Methods 
11.5.1 The match() and search() Methods 
11.5.2 Difference Between match() and search() Methods/Functions 
11.6 Some Important Methods of the re module 
11.6.1 re.findall(pattern, string)   
11.6.2 re.finditer(pattern, string) 
11.6.3 re.sub(pattern, repl, string, count=0, flags=0)  
11.6.4 A Special Note on Methods of re module and Methods of Pattern Object
11.7 Some Methods/Attributes of the Match Object   
11.7.1 Using group() Method of Match Object 
11.7.2 Using start() and end() Methods of Match Object 
11.7.3 The span() Method of Match Object   
11.7.4 Greedy versus Non-greedy Matching 
11.8 Some Common Scripts using RE 
**Chapter 12 Some Additional Advanced Topics**   
12.1 Introduction 2
12.2 Concepts of Shared Reference and Docstrings 2
12.2.1 Shared Reference and In-place Change (Relating to Function Calls) 2
12.2.2 Shared Reference, Equality and Sameness 
12.2.3 Docstring (In Function Definition) 2
12.3 Concepts Related to Python Module, __name__ attribute and Virtual  Environment  
12.3.1 How Python Interpreter Searches for Modules (Relating to import  statements)  
12.3.2 Problems That May Arise in Importing Modules   
12.3.3 Importing Only Some of the Attributes 
12.3.4 Using Import `*`   
12.3.5 Attributes with Leading Underscore and Import`*`  
12.3.6 Using `__file__` Attribute to Find Location of an Imported Module 
12.3.7 Using reload() 
12.3.8 Understanding the Use of the Command Line   
12.3.9 Running a Python Script from the Command Line 
12.3.10 `__name__` attribute  
12.3.11 Getting the ‘dependency’ Tree of a Module   
12.3.12 Virtual Environment  
12.4 Getting Help in Python and Some “Common Errors”  
12.4.1 Getting Help Using dir()   
12.4.2 Using help()   
12.4.3 Some Common Errors (Part 1)  
12.4.4 Some Common Errors in Python (Part 2)  
12.5 Using Jupyter Notebook in Interactive Mode   
12.5.1 Installation 
12.5.2 Using Widgets of ipywidgets   
12.5.3 Getting Details of a Widget   
12.5.4 The UI and Event Handler of a Widget   
12.6 Linting in Python  
12.6.1 Linting Packages Available  
12.6.2 pycodestyle   
12.6.3 Using pycodestyle   
12.6.4 Using pylint   
12.6.5 Pylint and Static Code Analysis in Spyder   
**Chapter 13 Object-Oriented Programming with Python** 
13.1 Introduction   
13.2 Basic Concept of Object-Oriented Programming  
13.2.1 Concept of Class, Object and Abstraction   
13.2.2 Concept of Data Abstraction   
13.2.3 Concept of Data Encapsulation through Class and Object   
13.2.4 Concept of Object   
13.2.5 Concept of Inheritance 3 
13.2.6 Concept of Polymorphism   
13.2.7 Concept of Operator Overloading   
13.2.8 Short Note on Function Overloading   
13.2.9 Creating a Simple Class and Simple Objects   
13.3 OOP Concepts Related Specifically to Python 3 
13.3.1 A Class which has an `__init__() `Method  
13.3.2 A Class which has Attributes, `__init__()` and also default Values for  `__init__()`   
13.3.3 A Class which has Attributes as well as Member Functions or Class Methods   
13.3.4 Concept of Instance Methods (or Methods Applicable to Objects), Static  Methods and Class Methods   
13.3.5 Function Decorator `@staticmethod`  
13.3.6 Data Hiding, Mangling, Pseudo-private Member Variables in a Class   
13.3.7 Static versus Dynamic Binding   
13.4 Some Common “Built in” Attributes and Methods of a Python Modules and  Classes  
13.4.1` __name__  `
13.4.2 `__module__ `  
13.4.3`__dict__  ` 
13.4.4 `__doc__`   
13.4.5` __bases__   `
13.4.6`__del__() `  
13.4.7 `some_object.__str__()`   
13.5 Common Mistakes while Creating Objects  
**Chapter 14 Inheritance and Namespace** 
14.1 Introduction 
14.2 Basics of Inheritance in Python   
14.2.1 Introduction to Subclassing (Inheritance)   
14.2.2 Types of Inheritance   
14.3 Single Inheritance   
14.3.1 A Simple Inheritance of all Functionalities of the Base Class or Parent  Class  
14.3.2 Inheritance, where the Derived Class has an __init__() Method of its  Own  
14.3.3 Both the Derived Class and the Parent Class have their Own `__init__()` Methods   
14.3.4 Use of super() to Call Methods other than init() of Base Class also 
14.3.5 Calling the `__init__()` Methods of the Parent Class  by Using the Name of the Parent Class  
14.3.6 Abstract Methods   
14.4 Multiple Inheritance   
14.4.1 Potential Problem in Multiple Inheritance   
14.4.2 Python in-built Class Attribute `__mro__`   
14.4.3 Abstract Methods and Abstract Class   
14.4.4 Creating Custom Containers   
14.5 Concept of Namespace 
14.5.1 `locals()` and `globals()`   
14.5.2 Namespace Dictionary` __dict__`   
**Chapter 15 File Operations in Python**   
15.1 Introduction  
15.2 Basics of file Operations in Python   
15.2.1 Basics of a File (Text versus Binary File) 3 
15.2.2 Opening and Closing Files   
15.2.3 The file_name Argument in open() Function   
15.2.4 Using open() Function to Create a New File   
15.2.5 File Object, Access Modes 3 
15.3 Reading and Writing a File   
15.3.1 The `read()` Method: (and the `tell()` method)   
15.3.2 `seek(offset[,from_what])` method  
15.3.3 `readline([size])` and `readlines([sizehint])`   
15.3.4 Writing to Files Using `write()` Method   
15.3.5 `writelines(aList)` Method of File Object  
15.4 Some More Advanced Concepts in File Operations  
15.4.1 Using the `“with”` Statement to Close File Automatically   
15.4.2 Python IO Stream Object   
15.4.3 Some Scripts in Python to Demonstrate Concepts of File Usage   
15.4.4 Pickling and Unpickling   
15.4.5 Pickle Module and Steps in Unpickling   
15.5 Some Useful Methods of the OS Module   
15.6 Writing Small Scripts for Inserting Data in a File 3 
**Chapter 16 Python Exceptions**  
16.1 Introduction   
16.2 Basic Concepts of Exceptions in Python   
16.2.1 Errors versus Exceptions  
16.2.2 The raise Statement   
16.2.3 The try-except-else Block of Code in Python   
16.2.4 The try-except-else-finally Block with Multiple Except and Except with  No Exception Type   
16.2.5 Using try-except Block to Read a File   
16.3 User-defined Exceptions   
16.4 Built-in Exceptions   
16.4.1 An except Clause may Name Multiple Exceptions as a  
Parenthesized Tuple   
**Chapter 17 Linear List Manipulation, Stacks and Queues**   
17.1 Introduction   
17.2 Basics of Data Structures and Lists in Python  
17.2.1 Data Structures   
17.2.2 Implementing list in Memory  
17.2.3 List Operation: Traversal  
17.2.4 Short Note on Insertion   
17.2.5 Inserting Element in a Sorted List   
17.2.6 Inserting an Element in a Sorted List using Bisect Module   
17.2.7 `insort(sequence, item)` Method   
17.3 Some Algorithms for Insertion, Deletion, Searching and Sorting of Lists   
17.3.1 Inserting an Item in a Sorted List Manually 
17.3.2 Deleting an Item whose `‘index’` is Given from a List (sorted or  
unsorted) 
17.3.3 Linear search  
17.3.4 Binary search   
17.3.5 Binary Search (Using Recursion)   
17.3.6 Selection sorting   
17.3.7 Bubble sort 
17.3.8 Insertion sort   
17.4 Stack and Queues Using Lists   
17.4.1 Stacks   
17.4.2 Implement Stack Using a Class  
17.4.3 Queue  
17.4.4 Queue Operations  
17.4.5 Implementing a Queue using Front and Rear Variable  
17.5 Some Common List Methods  
17.5.1 `list.append(x)` (equivalent to push in Python)  
17.5.2 `my_list.extend(seq)` 
17.5.3 `my_list.insert(i, x) `  
17.5.4 `my_list.remove(x) ` 
17.5.5 `my_list.pop([i])`   
17.5.6 `del list[idx]`   
17.5.7 `my_list.index(x)`  
17.5.8 `my_list.count(x)`  
17.5.9 `my_list.sort(cmp=None, key=None, reverse=False)`  
17.5.10` list.reverse()  `
**Chapter 18 NumPy, SciPy**   
18.1 Introduction   
18.2 Basics of NumPy and SciPy   
18.2.1 N-dimensional Array in NumPy   
18.2.2 Some NumPy Methods and Properties  
18.2.3 SciPy Basics   
18.2.4 Broadcasting in NumPy Array Operations  
18.2.5 Array Indexing in NumPy  
18.2.6 Infinity, Negative Infinity, Zero, Negative Zero and Some other Constants  in NumPy   
18.2.7 `np.linspace`  
18.2.8 Understanding `np.meshgrid()`  
18.2.9 Using NumPy, SciPy for Getting Some Basic Information about a Matrix 
18.3 Using NumPy for Various Operations  
18.3.1 Solving Linear System of Equations   
18.3.2 Multiplying a Matrix by a Vector   
18.3.3 Multiplication of a Diagonal Matrix to a Vector (Scaling)   
18.3.4 Matrix Multiplication as a Reflection  
18.3.5 Matrix Multiplication as Rotation   
18.3.6 Eigenvalues and Eigenvectors   
18.3.7 Eigen Decomposition   
18.3.8 Singular Value Decomposition   
**Chapter 19 SymPy**   
19.1 Introduction   
19.2 Basics of SymPy 1 
19.2.1 The` “symbols()”` Function   
19.2.2 Importing `Symbols` from Module `sympy.abc`   
19.2.3 SymPy Online Shell   
19.2.4 Equality Testing in SymPy using `“==”`  
19.2.5 Numeric Types in SymPy   
19.2.6 Using Operators on Combination of SymPy Objects and Python Objects   
19.3 Basics of SymPy 2   
19.3.1 Substitution in a SymPy expression  
19.3.2 Convert Python Strings to SymPy Expression and Evaluating it  
(Functions `sympify()` and `evalf())`   
19.3.3 `Singleton` Class in SymPy   
19.3.4 Functions in SymPy   
19.3.5 Lambda Class in SymPy   
19.4 Sets in SymPy  
19.4.1 FiniteSet   
19.4.2 Interval   
19.4.3 EmptySet   
19.4.4 Intersection  
19.4.5 Union  
19.4.6 ConditionSet  
19.4.7 Complement  
19.4.8 ImageSet (along with imageset function)  
19.4.9 Set Operations in SymPy  
19.5 Matrices   
19.6 The Equality Class and Eq 
19.7 The Solvers Module of SymPy   
19.7.1 solveset()   
19.8 The linsolve() Method   
19.9 Calculus with SymPy   
19.9.1 Differentiation  
19.9.2 Integration  
19.9.3 Finding limits (Lim)   
19.9.4 Ordinary Differential Equations (ODE)  
19.9.5 Solving ODE for an Undamped and Damped Harmonic Oscillator  
**Chapter 20 Pandas: Open Source Data Analysis and Manipulation Tool**  
20.1 Introduction   
20.2 Basics of pandas   
20.2.1 Series   
20.2.2 DataFrame  
20.2.3 Creating a DataFrame from List or from List of Lists  
20.2.4 Using the `Key: Value` Pair of a Dictionary to Create a `DataFrame` Object   
20.2.5 Panel   
20.3 Using pandas for Working on Files in Various Formats  
20.3.1 Using Pandas to Open `csv` Files   
20.3.2 Using Pandas to Read `html` Files   
20.3.3 Reading/Writing to `JSON` files 
Appendix 1 Downloading and Installing Python   
Appendix 2 Command Line, IDLE, Python Docs and Python Manual 
Appendix 3 Anaconda and Jupyter Notebook Basics 


   
